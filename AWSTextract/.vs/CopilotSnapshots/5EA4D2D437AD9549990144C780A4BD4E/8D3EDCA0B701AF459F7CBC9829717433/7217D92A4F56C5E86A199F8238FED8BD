using Amazon.Lambda.Core;
using Amazon.S3;
using Amazon.Textract;
using Amazon.BedrockRuntime;
using Amazon.Textract.Model;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Text.Json;
using System.Linq;
using System.IO;
using System.Text;
using Microsoft.Extensions.Caching.Memory;
using TextractProcessor.Services;
using TextractProcessor.Models;

[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace TextractProcessor
{
    public class Function
    {
        private const string LOG_GROUP = "/aws/lambda/textract-processor";
    private readonly string _functionName;

        private readonly IAmazonS3 _s3Client;
     private readonly IAmazonTextract _textractClient;
private readonly SchemaMapperService _schemaMapper;
        private readonly IMemoryCache _cache;
        private readonly TextractCacheService _textractCache;

        private const string BucketName = "testbucket-sudhir-bsi1";
        private const string TextractRoleArn = "arn:aws:iam::912532823432:role/accesstextract-role";
        private const string SnsTopicArn = "arn:aws:sns:us-east-1:912532823432:sns-topic-textract.fifo";
private static readonly string[] DocumentKeys = new[]
        {
  "uploads/2025000065659.tif",
            "uploads/2025000065659-1.tif"
        };
        private const int MaxRetries = 60;
      private const int RetryInterval = 5000;
 private const string OutputDirectory = "TextractResults";

        public Function()
        {
     _functionName = Environment.GetEnvironmentVariable("AWS_LAMBDA_FUNCTION_NAME") ?? "textract-processor";
            _s3Client = new AmazonS3Client();
            _textractClient = new AmazonTextractClient();
     _cache = new MemoryCache(new MemoryCacheOptions());
_textractCache = new TextractCacheService(OutputDirectory);

            var bedrockClient = new AmazonBedrockRuntimeClient();
  var modelConfig = BedrockModelConfig.TitanTextExpress;
   var bedrockService = new BedrockService(bedrockClient, _cache, modelConfig);
          _schemaMapper = new SchemaMapperService(bedrockService, _cache, OutputDirectory);

            Directory.CreateDirectory(OutputDirectory);
     }

        public async Task<List<ProcessingResult>> FunctionHandler(ILambdaContext context)
        {
    var results = new List<ProcessingResult>();
   foreach (var documentKey in DocumentKeys)
        {
            var startTime = DateTime.UtcNow;
try
      {
  LogEvent(context, $"Starting document processing for {documentKey}", additionalData: new Dictionary<string, object>
  {
          { "DocumentKey", documentKey },
             { "Bucket", BucketName }
           });

    // Try to get cached Textract response first
        var textractResponse = await _textractCache.GetCachedResponse(documentKey);

     if (textractResponse == null)
         {
      LogEvent(context, $"Cache miss - processing {documentKey} with Textract");
   textractResponse = await ProcessTextract(documentKey, context);

          if (textractResponse.JobStatus != "SUCCEEDED")
      {
   LogEvent(context, $"Textract processing failed for {documentKey}", "ERROR", new Dictionary<string, object>
               {
    { "Error", textractResponse.ErrorMessage }
       });

         results.Add(new ProcessingResult
  {
           Success = false,
    Error = textractResponse.ErrorMessage
    });
               continue;
    }

     LogMetric(context, "TextractProcessingTime", (DateTime.UtcNow - startTime).TotalMilliseconds);
      await _textractCache.CacheTextractResponse(documentKey, textractResponse);
         }
    else
   {
           LogEvent(context, $"Using cached Textract response for {documentKey}");
     LogMetric(context, "CacheHit", 1);
    }

    // Create simplified text-only response for Bedrock
      var simplifiedResponse = new SimplifiedTextractResponse
         {
   RawText = textractResponse.RawText,
    FormFields = textractResponse.FormData
       .SelectMany(dict => dict)
               .GroupBy(kvp => kvp.Key)
     .ToDictionary(
            g => g.Key,
         g => string.Join(" | ", g.Select(x => x.Value).Distinct())
        ),
    TableData = ExtractTableText(textractResponse.TableData)
             };

  LogEvent(context, $"Processing {documentKey} with Bedrock", additionalData: new Dictionary<string, object>
      {
      { "FormFieldCount", simplifiedResponse.FormFields.Count },
   { "TableCount", simplifiedResponse.TableData.Count }
              });

      var result = await _schemaMapper.ProcessAndMapSchema(
          simplifiedResponse,
     string.Empty,
                documentKey
        );

       var processingTime = (DateTime.UtcNow - startTime).TotalMilliseconds;
    LogMetric(context, "TotalProcessingTime", processingTime);
             LogMetric(context, "InputTokens", result.InputTokens);
         LogMetric(context, "OutputTokens", result.OutputTokens);

         LogEvent(context, $"Processing completed for {documentKey}", additionalData: new Dictionary<string, object>
         {
  { "ProcessingTimeMs", processingTime },
        { "InputTokens", result.InputTokens },
          { "OutputTokens", result.OutputTokens },
       { "Cost", result.TotalCost },
      { "OutputFile", result.MappedFilePath }
           });

          results.Add(result);
      }
             catch (Exception e)
      {
             LogEvent(context, $"Processing failed for {documentKey}", "ERROR", new Dictionary<string, object>
      {
          { "Error", e.Message },
         { "StackTrace", e.StackTrace }
    });

         results.Add(new ProcessingResult
       {
      Success = false,
    Error = e.Message
   });
        }
            }

    return results;
        }

        // Update ProcessTextract to accept documentKey parameter
      private async Task<TextractResponse> ProcessTextract(string documentKey, ILambdaContext context)
        {
            try
      {
       context.Logger.LogInformation($"Processing file: {documentKey} from bucket: {BucketName}");

  var startRequest = new StartDocumentAnalysisRequest
                {
               DocumentLocation = new DocumentLocation
  {
      S3Object = new S3Object
              {
        Bucket = BucketName,
  Name = documentKey
       }
             },
  FeatureTypes = new List<string> { "TABLES", "FORMS", "LAYOUT" },
      NotificationChannel = new NotificationChannel
          {
              RoleArn = TextractRoleArn,
         SNSTopicArn = SnsTopicArn
        }
       };

      var startResponse = await _textractClient.StartDocumentAnalysisAsync(startRequest);
                var jobId = startResponse.JobId;
                context.Logger.LogInformation($"Started Textract analysis job with ID: {jobId}");

                // Wait for the job to complete
                var result = await WaitForJobCompletion(jobId, context);
                if (result == null)
                {
                    return new TextractResponse { JobId = jobId, JobStatus = "FAILED" };
                }

                // Process the results
                var response = new TextractResponse
                {
                    JobId = jobId,
                    JobStatus = result.JobStatus,
                    FormData = new List<Dictionary<string, string>>(),
                    TableData = new List<Dictionary<string, object>>(),
                    Pages = new List<PageInfo>(),
                    RawText = string.Empty
                };

                var rawTextBuilder = new StringBuilder();
                var currentPage = new PageInfo
                {
                    PageNumber = 1,
                    Lines = new List<LineInfo>(),
                    Words = new List<WordInfo>(),
                    Dimensions = new Dictionary<string, float>()
                };

                // Get all results (handling pagination)
                string nextToken = null;
                do
                {
                    var getResultsRequest = new GetDocumentAnalysisRequest
                    {
                        JobId = jobId,
                        NextToken = nextToken
                    };

                    var analysisResult = await _textractClient.GetDocumentAnalysisAsync(getResultsRequest);
                    nextToken = analysisResult.NextToken;

                    // Process form fields
                    foreach (var block in analysisResult.Blocks)
                    {
                        if (block.BlockType == "KEY_VALUE_SET" && block.EntityTypes.Contains("KEY"))
                        {
                            var keyValuePair = ExtractKeyValuePair(block, analysisResult.Blocks);
                            if (keyValuePair != null)
                            {
                                response.FormData.Add(keyValuePair);
                            }
                        }
                        else if (block.BlockType == "PAGE")
                        {
                            if (currentPage.Lines.Any())
                            {
                                response.Pages.Add(currentPage);
                            }
                            currentPage = new PageInfo
                            {
                                PageNumber = block.Page ?? 1,
                                Lines = new List<LineInfo>(),
                                Words = new List<WordInfo>(),
                                Dimensions = new Dictionary<string, float>
                                {
                                    { "Width", GetFloatValue(block.Geometry?.BoundingBox?.Width) },
                                    { "Height", GetFloatValue(block.Geometry?.BoundingBox?.Height) }
                                }
                            };
                        }
                        else if (block.BlockType == "LINE")
                        {
                            var lineInfo = new LineInfo
                            {
                                Text = block.Text,
                                Confidence = block.Confidence ?? 0,
                                Geometry = new Dictionary<string, float>
                                {
                                    { "Left", GetFloatValue(block.Geometry?.BoundingBox?.Left) },
                                    { "Top", GetFloatValue(block.Geometry?.BoundingBox?.Top) },
                                    { "Width", GetFloatValue(block.Geometry?.BoundingBox?.Width) },
                                    { "Height", GetFloatValue(block.Geometry?.BoundingBox?.Height) }
                                }
                            };
                            currentPage.Lines.Add(lineInfo);
                            rawTextBuilder.AppendLine(block.Text);
                        }
                        else if (block.BlockType == "WORD")
                        {
                            var wordInfo = new WordInfo
                            {
                                Text = block.Text,
                                Confidence = block.Confidence ?? 0,
                                Geometry = new Dictionary<string, float>
                                {
                                    { "Left", GetFloatValue(block.Geometry?.BoundingBox?.Left) },
                                    { "Top", GetFloatValue(block.Geometry?.BoundingBox?.Top) },
                                    { "Width", GetFloatValue(block.Geometry?.BoundingBox?.Width) },
                                    { "Height", GetFloatValue(block.Geometry?.BoundingBox?.Height) }
                                }
                            };
                            currentPage.Words.Add(wordInfo);
                        }
                    }

                    // Process tables
                    ProcessTables(analysisResult.Blocks, response.TableData);

                } while (nextToken != null);

                if (currentPage.Lines.Any())
                {
                    response.Pages.Add(currentPage);
                }

                response.RawText = rawTextBuilder.ToString();

                // Log and save the results
                context.Logger.LogInformation($"Analysis completed. Found {response.FormData.Count} form fields, {response.TableData.Count} tables, and {response.Pages.Count} pages.");
                var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                var baseFileName = Path.GetFileNameWithoutExtension(DocumentKey.Split('/').Last());

                // Save JSON format
                var jsonFileName = Path.Combine(OutputDirectory, $"{baseFileName}_{timestamp}.json");
                var jsonContent = JsonSerializer.Serialize(response, new JsonSerializerOptions { WriteIndented = true });
                await File.WriteAllTextAsync(jsonFileName, jsonContent);
                context.Logger.LogInformation($"Saved JSON results to: {jsonFileName}");

                // Save human-readable format
                var textFileName = Path.Combine(OutputDirectory, $"{baseFileName}_{timestamp}.txt");
                await SaveEnhancedHumanReadableFormat(response, textFileName);
                context.Logger.LogInformation($"Saved readable results to: {textFileName}");

                return response;
            }
            catch (Exception e)
   {
  context.Logger.LogError($"Error processing file {documentKey} from bucket {BucketName}: {e.Message}");
   return new TextractResponse
     {
          JobStatus = "ERROR",
       ErrorMessage = e.Message
     };
     }
        }

    // ... [Rest of the existing methods remain the same]
    }
}