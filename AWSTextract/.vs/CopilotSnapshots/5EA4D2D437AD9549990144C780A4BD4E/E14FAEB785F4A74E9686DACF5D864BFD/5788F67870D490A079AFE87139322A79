using System.Text.Json;
using Microsoft.Extensions.Caching.Memory;

namespace TextractProcessor.Services
{
    public class SchemaMapperService
    {
        private readonly BedrockService _bedrockService;
        private readonly IMemoryCache _cache;
    private readonly string _outputDirectory;

        public SchemaMapperService(BedrockService bedrockService, IMemoryCache cache, string outputDirectory)
        {
       _bedrockService = bedrockService;
  _cache = cache;
            _outputDirectory = outputDirectory;
     }

        public async Task<ProcessingResult> ProcessAndMapSchema(
         TextractResponse textractResults,
            string schemaFilePath,
   string originalFileName)
        {
        try
     {
                // Read the target schema
     var targetSchema = await File.ReadAllTextAsync(schemaFilePath);

                // Process with Bedrock
                var (mappedJson, inputTokens, outputTokens) = await _bedrockService.ProcessTextractResults(
        textractResults,
                  targetSchema
    );

     // Save the mapped result
        var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            var baseFileName = Path.GetFileNameWithoutExtension(originalFileName);
       var mappedFilePath = Path.Combine(_outputDirectory, $"{baseFileName}_mapped_{timestamp}.json");

        await File.WriteAllTextAsync(mappedFilePath, mappedJson);

                return new ProcessingResult
   {
        Success = true,
       MappedFilePath = mappedFilePath,
        InputTokens = inputTokens,
              OutputTokens = outputTokens,
               TotalCost = CalculateCost(inputTokens, outputTokens)
           };
       }
    catch (Exception ex)
            {
   return new ProcessingResult
             {
       Success = false,
         Error = ex.Message
    };
      }
   }

        private decimal CalculateCost(int inputTokens, int outputTokens)
        {
            // Claude v2 pricing (as of 2024)
  const decimal INPUT_COST_PER_1K_TOKENS = 0.008m;
   const decimal OUTPUT_COST_PER_1K_TOKENS = 0.024m;

        var inputCost = (inputTokens / 1000m) * INPUT_COST_PER_1K_TOKENS;
            var outputCost = (outputTokens / 1000m) * OUTPUT_COST_PER_1K_TOKENS;

            return inputCost + outputCost;
        }
    }

    public class ProcessingResult
    {
        public bool Success { get; set; }
        public string MappedFilePath { get; set; }
      public string Error { get; set; }
        public int InputTokens { get; set; }
      public int OutputTokens { get; set; }
        public decimal TotalCost { get; set; }
    }
}