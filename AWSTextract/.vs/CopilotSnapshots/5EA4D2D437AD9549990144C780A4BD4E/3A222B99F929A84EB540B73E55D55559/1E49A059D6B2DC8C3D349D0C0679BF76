using Amazon.BedrockRuntime;
using Amazon.BedrockRuntime.Model;
using Microsoft.Extensions.Caching.Memory;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using TextractProcessor.Models;
using Amazon.Lambda.Core;

namespace TextractProcessor.Services
{
    public class BedrockService
    {
        private readonly IAmazonBedrockRuntime _bedrockClient;
        private readonly IMemoryCache _cache;
        private readonly BedrockModelConfig _modelConfig;
        private const int CACHE_DURATION_MINUTES = 60;

        public BedrockService(
           IAmazonBedrockRuntime bedrockClient,
   IMemoryCache cache,
       BedrockModelConfig modelConfig = null)
        {
            _bedrockClient = bedrockClient ?? throw new ArgumentNullException(nameof(bedrockClient));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _modelConfig = modelConfig ?? BedrockModelConfig.TitanTextExpress;
        }

        public async Task<(string response, int inputTokens, int outputTokens)> ProcessTextractResults(
            SimplifiedTextractResponse textractResults,
   string targetSchema,
   ILambdaContext context = null)
        {
            try
            {
                if (textractResults == null) throw new ArgumentNullException(nameof(textractResults));
   if (string.IsNullOrWhiteSpace(targetSchema)) throw new ArgumentException("Target schema cannot be empty", nameof(targetSchema));

     var requestId = context?.AwsRequestId ?? Guid.NewGuid().ToString();
     context?.Logger.LogLine($"[RequestId: {requestId}] Starting Textract processing");

      // Calculate hash for caching
 var cacheKey = CalculateHash(JsonSerializer.Serialize(textractResults) + targetSchema + _modelConfig.ModelId);
  
        if (_cache.TryGetValue<CachedResponse>(cacheKey, out var cachedResponse))
  {
            context?.Logger.LogLine($"[RequestId: {requestId}] Cache hit - returning cached response");
            return (cachedResponse.Response, cachedResponse.InputTokens, cachedResponse.OutputTokens);
      }

        context?.Logger.LogLine($"[RequestId: {requestId}] Cache miss - processing with Bedrock");
        var prompt = CreatePrompt(textractResults, targetSchema);
     context?.Logger.LogLine($"[RequestId: {requestId}] Invoking Bedrock model {_modelConfig.ModelId}");

        // Create model-specific request
        var request = CreateModelRequest(prompt);
    var jsonOptions = new JsonSerializerOptions
        {
    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
         DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        };

        var requestJson = JsonSerializer.Serialize(request, jsonOptions);
        context?.Logger.LogLine($"[RequestId: {requestId}] Request payload size: {requestJson.Length} bytes");

        var modelRequest = new InvokeModelRequest
        {
         ModelId = _modelConfig.ModelId,
         ContentType = "application/json",
 Accept = "application/json",
       Body = new MemoryStream(Encoding.UTF8.GetBytes(requestJson))
  };

      context?.Logger.LogLine($"[RequestId: {requestId}] Sending request to Bedrock");
        var startTime = DateTime.UtcNow;
        var response = await _bedrockClient.InvokeModelAsync(modelRequest);
        var duration = DateTime.UtcNow - startTime;
        context?.Logger.LogLine($"[RequestId: {requestId}] Bedrock response received in {duration.TotalMilliseconds:F0}ms");

        using var reader = new StreamReader(response.Body);
        var responseJson = await reader.ReadToEndAsync();
      
  var (outputText, inputTokens, outputTokens) = ParseResponse(responseJson);
     context?.Logger.LogLine($"[RequestId: {requestId}] Processing metrics:" +
            $"\n- Input tokens: {inputTokens}" +
       $"\n- Output tokens: {outputTokens}" +
        $"\n- Response size: {outputText.Length} chars");

        var cacheEntry = new CachedResponse
        {
 Response = outputText,
    InputTokens = inputTokens,
        OutputTokens = outputTokens
        };

        _cache.Set(cacheKey, cacheEntry, TimeSpan.FromMinutes(CACHE_DURATION_MINUTES));
        context?.Logger.LogLine($"[RequestId: {requestId}] Response cached with key: {cacheKey}");

return (outputText, inputTokens, outputTokens);
    }
    catch (Exception e)
    {
        context?.Logger.LogLine($"Error in Bedrock service: {e.Message}\nStack trace: {e.StackTrace}");
        throw;
    }
        }

        private object CreateModelRequest(string prompt)
        {
            return _modelConfig.RequestFormat switch
            {
                RequestFormat.Titan => new
                {
inputText = prompt,
            textGenerationConfig = new
         {
          maxTokenCount = _modelConfig.MaxTokens,
                temperature = 0.1, // Lower temperature for more precise JSON generation
     topP = 1.0,
                stopSequences = new[] { "```", "Human:", "Assistant:" },
repetitionPenalty = 1.2, // Helps prevent repetitive text
                topK = 10 // Limit token selection for more focused output
            }
        },
        RequestFormat.Claude => new
        {
   anthropic_version = _modelConfig.Version,
          max_tokens = _modelConfig.MaxTokens,
    temperature = _modelConfig.Temperature,
            messages = new[]
       {
   new { role = "user", content = prompt }
            }
        },
      _ => throw new ArgumentException($"Unsupported model format: {_modelConfig.RequestFormat}")
    };
}

        private (string outputText, int inputTokens, int outputTokens) ParseResponse(string responseJson)
        {
            var options = new JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true
            };

            return _modelConfig.ResponseFormat switch
            {
                ResponseFormat.Titan => ParseTitanResponse(responseJson, options),
                ResponseFormat.Claude => ParseClaudeResponse(responseJson, options),
                _ => throw new ArgumentException($"Unsupported response format: {_modelConfig.ResponseFormat}")
            };
        }

        private static (string, int, int) ParseTitanResponse(string responseJson, JsonSerializerOptions options)
        {
            var response = JsonSerializer.Deserialize<TitanResponse>(responseJson, options);
            if (response?.Results == null || response.Results.Count == 0)
            {
                throw new InvalidOperationException($"Invalid Titan response format: {responseJson}");
            }

            return (
        response.Results[0].OutputText,
      response.Results[0].InputTextTokenCount,
            response.Results[0].OutputTextTokenCount
          );
        }

        private static (string, int, int) ParseClaudeResponse(string responseJson, JsonSerializerOptions options)
        {
            var response = JsonSerializer.Deserialize<ClaudeResponse>(responseJson, options);
            return (
 response?.Content ?? string.Empty,
     response?.Usage?.InputTokens ?? EstimateTokenCount(responseJson),
      response?.Usage?.OutputTokens ?? EstimateTokenCount(response?.Content)
            );
        }

        private static string CreatePrompt(SimplifiedTextractResponse textractResults, string targetSchema)
        {
            // Ensure we have data to process
            if (string.IsNullOrEmpty(textractResults.RawText) && 
                (textractResults.FormFields == null || !textractResults.FormFields.Any()) &&
   (textractResults.TableData == null || !textractResults.TableData.Any()))
    {
     throw new ArgumentException("No data available in the textract results to process");
    }

    var sourceDataJson = JsonSerializer.Serialize(textractResults, new JsonSerializerOptions
    {
        WriteIndented = true,
  DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
    });

    return $@"You are a JSON transformation expert. Your task is to convert the provided extracted document data into a specific JSON format according to the target schema.

SOURCE DATA:
{{
    ""rawText"": ""{textractResults.RawText?.Replace("\"", "\\\"")}"",
    ""formFields"": {JsonSerializer.Serialize(textractResults.FormFields)},
    ""tableData"": {JsonSerializer.Serialize(textractResults.TableData)}
}}

TARGET SCHEMA:
{targetSchema}

TASK:
Create a single valid JSON object that matches the target schema structure using the provided source data.

REQUIREMENTS:
1. Output must be a valid JSON object
2. Follow these type conversions:
   - Use number type for numeric values (no quotes)
   - Use string type for text values (with quotes)
   - Use true/false for boolean values (no quotes)
   - Use ""YYYY-MM-DD"" format for dates
3. Use null for required fields that cannot be mapped
4. Match all property names exactly as shown in the target schema
5. Include only the properties defined in the target schema

IMPORTANT: Return ONLY the JSON object. Do not include any explanations or additional text.
The response should start with '{{' and end with '}}'";
}

        private static string CalculateHash(string input)
        {
            using var sha256 = SHA256.Create();
            var bytes = Encoding.UTF8.GetBytes(input);
            var hash = sha256.ComputeHash(bytes);
            return Convert.ToBase64String(hash);
        }

        private static int EstimateTokenCount(string text)
        {
            return text?.Length / 4 ?? 0;
        }
    }

    public class ClaudeResponse
    {
        public string Content { get; set; } = string.Empty;
        public Usage Usage { get; set; }
    }

    public class Usage
    {
        public int InputTokens { get; set; }
        public int OutputTokens { get; set; }
    }

    public class TitanResponse
    {
        public List<TitanResult> Results { get; set; } = new();
    }

    public class TitanResult
    {
        public string OutputText { get; set; } = string.Empty;
        public string CompletionReason { get; set; } = string.Empty;
        public int InputTextTokenCount { get; set; }
        public int OutputTextTokenCount { get; set; }
    }

    public class CachedResponse
    {
        public string Response { get; set; } = string.Empty;
        public int InputTokens { get; set; }
        public int OutputTokens { get; set; }
        public DateTime CachedAt { get; set; } = DateTime.UtcNow;
    }
}