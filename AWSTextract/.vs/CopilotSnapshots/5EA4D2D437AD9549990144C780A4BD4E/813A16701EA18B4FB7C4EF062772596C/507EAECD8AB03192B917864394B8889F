using Amazon.Lambda.Core;
using Amazon.S3;
using Amazon.Textract;
using Amazon.BedrockRuntime;
using Amazon.Textract.Model;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Text.Json;
using System.Linq;
using System.IO;
using System.Text;
using Microsoft.Extensions.Caching.Memory;
using TextractProcessor.Services;
using TextractProcessor.Models;

[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace TextractProcessor
{
    public class Function
    {
        private const string LOG_GROUP = "/aws/lambda/textract-processor";
        private readonly string _functionName;

        private readonly IAmazonS3 _s3Client;
        private readonly IAmazonTextract _textractClient;
        private readonly SchemaMapperService _schemaMapper;
        private readonly IMemoryCache _cache;
        private readonly TextractCacheService _textractCache;

        private const string BucketName = "testbucket-sudhir-bsi1";
        private const string TextractRoleArn = "arn:aws:iam::912532823432:role/accesstextract-role";
        private const string SnsTopicArn = "arn:aws:sns:us-east-1:912532823432:sns-topic-textract.fifo";
        private static readonly string[] DocumentKeys = new[]
        {
      "uploads/2025000065659.tif",
    "uploads/2025000065659-1.tif"
        };
        private const int MaxRetries = 60;
        private const int RetryInterval = 5000;
        private const string OutputDirectory = "TextractResults";

        public Function()
        {
            _functionName = Environment.GetEnvironmentVariable("AWS_LAMBDA_FUNCTION_NAME") ?? "textract-processor";
            _s3Client = new AmazonS3Client();
            _textractClient = new AmazonTextractClient();
            _cache = new MemoryCache(new MemoryCacheOptions());
            _textractCache = new TextractCacheService(OutputDirectory);

            var bedrockClient = new AmazonBedrockRuntimeClient();
            var modelConfig = BedrockModelConfig.TitanTextExpress;
            var bedrockService = new BedrockService(bedrockClient, _cache, modelConfig);
            _schemaMapper = new SchemaMapperService(bedrockService, _cache, OutputDirectory);

            Directory.CreateDirectory(OutputDirectory);
        }

        private void LogMetric(ILambdaContext context, string metricName, double value, Dictionary<string, string> dimensions = null)
        {
            var logEntry = new
            {
                MetricName = metricName,
                Value = value,
                Unit = "Count",
                Dimensions = dimensions ?? new Dictionary<string, string>(),
                Timestamp = DateTime.UtcNow,
                RequestId = context?.AwsRequestId
            };

            context?.Logger.LogLine($"METRIC#{JsonSerializer.Serialize(logEntry)}");
        }

        private void LogEvent(ILambdaContext context, string message, string level = "INFO", Dictionary<string, object> additionalData = null)
        {
            var logEntry = new
            {
                Timestamp = DateTime.UtcNow,
                Level = level,
                RequestId = context?.AwsRequestId,
                FunctionName = _functionName,
                Message = message,
                AdditionalData = additionalData
            };

            context?.Logger.LogLine(JsonSerializer.Serialize(logEntry));
        }

        private float GetFloatValue(float? nullableValue)
        {
            return nullableValue ?? 0f;
        }

        public async Task<List<ProcessingResult>> FunctionHandler(ILambdaContext context)
        {
            var results = new List<ProcessingResult>();
            foreach (var documentKey in DocumentKeys)
            {
                var startTime = DateTime.UtcNow;
                try
                {
                    LogEvent(context, $"Starting document processing for {documentKey}", additionalData: new Dictionary<string, object>
  {
       { "DocumentKey", documentKey },
   { "Bucket", BucketName }
      });

                    var textractResponse = await _textractCache.GetCachedResponse(documentKey);

                    if (textractResponse == null)
                    {
                        LogEvent(context, $"Cache miss - processing {documentKey} with Textract");
                        textractResponse = await ProcessTextract(documentKey, context);

                        if (textractResponse.JobStatus != "SUCCEEDED")
                        {
                            LogEvent(context, $"Textract processing failed for {documentKey}", "ERROR", new Dictionary<string, object>
     {
     { "Error", textractResponse.ErrorMessage }
         });

                            results.Add(new ProcessingResult
                            {
                                Success = false,
                                Error = textractResponse.ErrorMessage
                            });
                            continue;
                        }

                        LogMetric(context, "TextractProcessingTime", (DateTime.UtcNow - startTime).TotalMilliseconds);
                        await _textractCache.CacheTextractResponse(documentKey, textractResponse);
                    }
                    else
                    {
                        LogEvent(context, $"Using cached Textract response for {documentKey}");
                        LogMetric(context, "CacheHit", 1);
                    }

                    var simplifiedResponse = new SimplifiedTextractResponse
                    {
                        RawText = textractResponse.RawText,
                        FormFields = textractResponse.FormData
                          .SelectMany(dict => dict)
            .GroupBy(kvp => kvp.Key)
               .ToDictionary(
          g => g.Key,
                  g => string.Join(" | ", g.Select(x => x.Value).Distinct())
            ),
                        TableData = ExtractTableText(textractResponse.TableData)
                    };

                    LogEvent(context, $"Processing {documentKey} with Bedrock", additionalData: new Dictionary<string, object>
      {
     { "FormFieldCount", simplifiedResponse.FormFields.Count },
     { "TableCount", simplifiedResponse.TableData.Count }
              });

                    var result = await _schemaMapper.ProcessAndMapSchema(
                         simplifiedResponse,
               string.Empty,
                documentKey
             );

                    var processingTime = (DateTime.UtcNow - startTime).TotalMilliseconds;
                    LogMetric(context, "TotalProcessingTime", processingTime);
                    LogMetric(context, "InputTokens", result.InputTokens);
                    LogMetric(context, "OutputTokens", result.OutputTokens);

                    LogEvent(context, $"Processing completed for {documentKey}", additionalData: new Dictionary<string, object>
            {
      { "ProcessingTimeMs", processingTime },
       { "InputTokens", result.InputTokens },
          { "OutputTokens", result.OutputTokens },
        { "Cost", result.TotalCost },
          { "OutputFile", result.MappedFilePath }
       });

                    results.Add(result);
                }
                catch (Exception e)
                {
                    LogEvent(context, $"Processing failed for {documentKey}", "ERROR", new Dictionary<string, object>
       {
           { "Error", e.Message },
    { "StackTrace", e.StackTrace }
          });

                    results.Add(new ProcessingResult
                    {
                        Success = false,
                        Error = e.Message
                    });
                }
            }

            return results;
        }

        private async Task<TextractResponse> ProcessTextract(string documentKey, ILambdaContext context)
        {
            try
            {
                context.Logger.LogInformation($"Processing file: {documentKey} from bucket: {BucketName}");

                var startRequest = new StartDocumentAnalysisRequest
                {
                    DocumentLocation = new DocumentLocation
                    {
                        S3Object = new S3Object
                        {
                            Bucket = BucketName,
                            Name = documentKey
                        }
                    },
                    FeatureTypes = new List<string> { "TABLES", "FORMS", "LAYOUT" },
                    NotificationChannel = new NotificationChannel
                    {
                        RoleArn = TextractRoleArn,
                        SNSTopicArn = SnsTopicArn
                    }
                };

                var startResponse = await _textractClient.StartDocumentAnalysisAsync(startRequest);
                var jobId = startResponse.JobId;
                context.Logger.LogInformation($"Started Textract analysis job with ID: {jobId}");

                var result = await WaitForJobCompletion(jobId, context);
                if (result == null)
                {
                    return new TextractResponse { JobId = jobId, JobStatus = "FAILED" };
                }

                var response = new TextractResponse
                {
                    JobId = jobId,
                    JobStatus = result.JobStatus,
                    FormData = new List<Dictionary<string, string>>(),
                    TableData = new List<Dictionary<string, object>>(),
                    Pages = new List<PageInfo>(),
                    RawText = string.Empty
                };

                var rawTextBuilder = new StringBuilder();
                var currentPage = CreateNewPage(1);

                string nextToken = null;
                do
                {
                    var getResultsRequest = new GetDocumentAnalysisRequest
                    {
                        JobId = jobId,
                        NextToken = nextToken
                    };

                    var analysisResult = await _textractClient.GetDocumentAnalysisAsync(getResultsRequest);
                    nextToken = analysisResult.NextToken;

                    ProcessBlocks(analysisResult.Blocks, response, ref currentPage, rawTextBuilder);
                    ProcessTables(analysisResult.Blocks, response.TableData);

                } while (nextToken != null);

                if (currentPage.Lines.Any())
                {
                    response.Pages.Add(currentPage);
                }

                response.RawText = rawTextBuilder.ToString();

                SaveResults(response, documentKey, context);

                return response;
            }
            catch (Exception e)
            {
                context.Logger.LogError($"Error processing file {documentKey} from bucket {BucketName}: {e.Message}");
                return new TextractResponse
                {
                    JobStatus = "ERROR",
                    ErrorMessage = e.Message
                };
            }
        }

        private PageInfo CreateNewPage(int pageNumber)
        {
            return new PageInfo
            {
                PageNumber = pageNumber,
                Lines = new List<LineInfo>(),
                Words = new List<WordInfo>(),
                Dimensions = new Dictionary<string, float>()
            };
        }

        private void ProcessBlocks(List<Block> blocks, TextractResponse response, ref PageInfo currentPage, StringBuilder rawTextBuilder)
        {
            foreach (var block in blocks)
            {
                switch (block.BlockType)
                {
                    case "KEY_VALUE_SET" when block.EntityTypes.Contains("KEY"):
                        var keyValuePair = ExtractKeyValuePair(block, blocks);
                        if (keyValuePair != null)
                        {
                            response.FormData.Add(keyValuePair);
                        }
                        break;

                    case "PAGE":
                        if (currentPage.Lines.Any())
                        {
                            response.Pages.Add(currentPage);
                        }
                        currentPage = CreateNewPage(block.Page ?? 1);
                        currentPage.Dimensions["Width"] = GetFloatValue(block.Geometry?.BoundingBox?.Width);
                        currentPage.Dimensions["Height"] = GetFloatValue(block.Geometry?.BoundingBox?.Height);
                        break;

                    case "LINE":
                        ProcessLine(block, currentPage, rawTextBuilder);
                        break;

                    case "WORD":
                        ProcessWord(block, currentPage);
                        break;
                }
            }
        }

        private void ProcessLine(Block block, PageInfo currentPage, StringBuilder rawTextBuilder)
        {
            var lineInfo = new LineInfo
            {
                Text = block.Text,
                Confidence = block.Confidence ?? 0,
                Geometry = CreateGeometryDictionary(block.Geometry?.BoundingBox)
            };
            currentPage.Lines.Add(lineInfo);
            rawTextBuilder.AppendLine(block.Text);
        }

        private void ProcessWord(Block block, PageInfo currentPage)
        {
            var wordInfo = new WordInfo
            {
                Text = block.Text,
                Confidence = block.Confidence ?? 0,
                Geometry = CreateGeometryDictionary(block.Geometry?.BoundingBox)
            };
            currentPage.Words.Add(wordInfo);
        }

        private Dictionary<string, float> CreateGeometryDictionary(BoundingBox boundingBox)
        {
            return new Dictionary<string, float>
            {
            { "Left", GetFloatValue(boundingBox?.Left) },
                { "Top", GetFloatValue(boundingBox?.Top) },
        { "Width", GetFloatValue(boundingBox?.Width) },
    { "Height", GetFloatValue(boundingBox?.Height) }
        };
        }

        private async void SaveResults(TextractResponse response, string documentKey, ILambdaContext context)
        {
            try
            {
                context.Logger.LogInformation($"Analysis completed. Found {response.FormData.Count} form fields, {response.TableData.Count} tables, and {response.Pages.Count} pages.");

                var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                var baseFileName = Path.GetFileNameWithoutExtension(documentKey.Split('/').Last());

                var jsonFileName = Path.Combine(OutputDirectory, $"{baseFileName}_{timestamp}.json");
                var jsonContent = JsonSerializer.Serialize(response, new JsonSerializerOptions { WriteIndented = true });
                await File.WriteAllTextAsync(jsonFileName, jsonContent);
                context.Logger.LogInformation($"Saved JSON results to: {jsonFileName}");

                var textFileName = Path.Combine(OutputDirectory, $"{baseFileName}_{timestamp}.txt");
                await SaveEnhancedHumanReadableFormat(response, textFileName, documentKey);
                context.Logger.LogInformation($"Saved readable results to: {textFileName}");
            }
            catch (Exception e)
            {
                context.Logger.LogError($"Error saving results for {documentKey}: {e.Message}");
            }
        }

        private List<List<string>> ExtractTableText(List<Dictionary<string, object>> tableDictionaries)
        {
            var tableTexts = new List<List<string>>();

            foreach (var tableDict in tableDictionaries)
            {
                if (tableDict.TryGetValue("Cells", out var cellsObj) &&
         cellsObj is List<Dictionary<string, string>> cells)
                {
                    var tableRows = cells
              .GroupBy(c => int.Parse(c["RowIndex"]))
               .OrderBy(g => g.Key)
            .Select(g => g.OrderBy(c => int.Parse(c["ColumnIndex"]))
               .Select(c => c["Text"])
                     .ToList())
                    .ToList();

                    tableTexts.Add(tableRows.SelectMany(row => row).ToList());
                }
            }

            return tableTexts;
        }

        private async Task<GetDocumentAnalysisResponse> WaitForJobCompletion(string jobId, ILambdaContext context)
        {
            for (int i = 0; i < MaxRetries; i++)
            {
                var getResultsRequest = new GetDocumentAnalysisRequest { JobId = jobId };
                var result = await _textractClient.GetDocumentAnalysisAsync(getResultsRequest);

                if (result.JobStatus == "SUCCEEDED")
                {
                    return result;
                }
                else if (result.JobStatus == "FAILED")
                {
                    context.Logger.LogError($"Textract job failed: {result.StatusMessage}");
                    return null;
                }

                await Task.Delay(RetryInterval);
            }

            context.Logger.LogError("Job did not complete within the maximum retry attempts");
            return null;
        }

        private void ProcessTables(List<Block> blocks, List<Dictionary<string, object>> tableData)
        {
            var tables = blocks.Where(b => b.BlockType == "TABLE");

            foreach (var table in tables)
            {
                var tableCells = blocks.Where(b =>
                        b.BlockType == "CELL" &&
                        b.Relationships?.Any(r => r.Type == "CHILD") == true &&
                b.Id.StartsWith(table.Id)).ToList();

                var rowCount = tableCells.Max(c => c.RowIndex);
                var columnCount = tableCells.Max(c => c.ColumnIndex);

                var tableDict = new Dictionary<string, object>
{
                  { "TableId", table.Id },
       { "Rows", rowCount },
 { "Columns", columnCount },
         { "Cells", new List<Dictionary<string, string>>() }
          };

                foreach (var cell in tableCells)
                {
                    var cellText = string.Join(" ", cell.Relationships
                          .FirstOrDefault(r => r.Type == "CHILD")?
                        .Ids
                     .Select(id => blocks.First(b => b.Id == id).Text) ?? Array.Empty<string>());

                    ((List<Dictionary<string, string>>)tableDict["Cells"]).Add(new Dictionary<string, string>
 {
              { "RowIndex", cell.RowIndex.ToString() },
       { "ColumnIndex", cell.ColumnIndex.ToString() },
                 { "Text", cellText.Trim() }
  });
                }

                tableData.Add(tableDict);
            }
        }

        private Dictionary<string, string> ExtractKeyValuePair(Block keyBlock, List<Block> blocks)
        {
            try
            {
                var keyText = string.Join(" ", keyBlock.Relationships
                   .FirstOrDefault(r => r.Type == "CHILD")?
              .Ids
                       .Select(id => blocks.First(b => b.Id == id).Text) ?? Array.Empty<string>());

                var valueBlock = blocks.FirstOrDefault(b =>
               keyBlock.Relationships.Any(r => r.Type == "VALUE" && r.Ids.Contains(b.Id)));

                if (valueBlock != null)
                {
                    var valueText = string.Join(" ", valueBlock.Relationships
                           .FirstOrDefault(r => r.Type == "CHILD")?
                     .Ids
                    .Select(id => blocks.First(b => b.Id == id).Text) ?? Array.Empty<string>());

                    return new Dictionary<string, string> { { keyText.Trim(), valueText.Trim() } };
                }
            }
            catch (Exception)
            {
                // Skip malformed key-value pairs
            }

            return null;
        }

        private async Task SaveEnhancedHumanReadableFormat(TextractResponse response, string filePath, string documentKey)
        {
            var sb = new StringBuilder();
            sb.AppendLine("Textract Analysis Results");
            sb.AppendLine("=======================");
            sb.AppendLine($"Document: {documentKey}");
            sb.AppendLine($"Job ID: {response.JobId}");
            sb.AppendLine($"Status: {response.JobStatus}");
            sb.AppendLine();

            sb.AppendLine("Document Statistics");
            sb.AppendLine("------------------");
            sb.AppendLine($"Total Pages: {response.Pages.Count}");
            sb.AppendLine($"Total Lines: {response.Pages.Sum(p => p.Lines.Count)}");
            sb.AppendLine($"Total Words: {response.Pages.Sum(p => p.Words.Count)}");
            sb.AppendLine($"Form Fields: {response.FormData.Count}");
            sb.AppendLine();

            sb.AppendLine("Raw Text Content");
            sb.AppendLine("---------------");
            sb.AppendLine(response.RawText);
            sb.AppendLine();

            foreach (var page in response.Pages)
            {
                sb.AppendLine($"Page {page.PageNumber} Details");
                sb.AppendLine("--------------------");
                sb.AppendLine($"Page Dimensions: Width={page.Dimensions["Width"]:F3}, Height={page.Dimensions["Height"]:F3}");
                sb.AppendLine();

                sb.AppendLine("Lines with Position and Confidence:");
                foreach (var line in page.Lines.OrderBy(l => l.Geometry["Top"]))
                {
                    sb.AppendLine($"[Confidence: {line.Confidence:F1}%] [Position: ({line.Geometry["Left"]:F3}, {line.Geometry["Top"]:F3})] {line.Text}");
                }
                sb.AppendLine();

                sb.AppendLine("Words with Details:");
                foreach (var word in page.Words.OrderBy(w => w.Geometry["Top"]).ThenBy(w => w.Geometry["Left"]))
                {
                    sb.AppendLine($"[Confidence: {word.Confidence:F1}%] [Position: ({word.Geometry["Left"]:F3}, {word.Geometry["Top"]:F3})] {word.Text}");
                }
                sb.AppendLine();
            }

            if (response.FormData?.Any() == true)
            {
                sb.AppendLine("Form Fields");
                sb.AppendLine("-----------");
                foreach (var field in response.FormData)
                {
                    foreach (var kvp in field)
                    {
                        sb.AppendLine($"{kvp.Key}: {kvp.Value}");
                    }
                }
                sb.AppendLine();
            }

            if (!string.IsNullOrEmpty(response.ErrorMessage))
            {
                sb.AppendLine("Errors");
                sb.AppendLine("------");
                sb.AppendLine(response.ErrorMessage);
            }

            await File.WriteAllTextAsync(filePath, sb.ToString());
        }
    }
}