using Amazon;
using Amazon.BedrockRuntime;
using Amazon.BedrockRuntime.Model;
using Amazon.Lambda.Core;
using Microsoft.Extensions.Caching.Memory;
using System.Linq;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using TextractProcessor.Models;

namespace TextractProcessor.Services
{
    public class BedrockService
    {
        private readonly IAmazonBedrockRuntime _bedrockClient;
        private readonly IMemoryCache _cache;
        private readonly BedrockModelConfig _modelConfig;
        private const int CACHE_DURATION_MINUTES = 60;
        private const string PROMPT_CACHE_PREFIX = "prompt_";
        // Remove snake_case from request serialization; use per-model options instead
        // private static readonly JsonSerializerOptions _jsonOptions = new()
        // {
        // PropertyNamingPolicy = new SnakeCaseNamingPolicy(),
        // DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        // };

        public BedrockService(IAmazonBedrockRuntime bedrockClient, IMemoryCache cache, BedrockModelConfig modelConfig = null)
        {
            _bedrockClient = bedrockClient ?? throw new ArgumentNullException(nameof(bedrockClient));
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _modelConfig = modelConfig ?? BedrockModelConfig.TitanTextExpress;
        }

        private static class JsonExtractor
        {
            public static string ExtractFirstJsonObject(string text)
            {
                // Try to find records array first
                try
                {
                    using var doc = JsonDocument.Parse(text);
                    if (doc.RootElement.TryGetProperty("records", out var records) &&
                        records.ValueKind == JsonValueKind.Array)
                    {
                        // Get the first record
                        var recordArray = records.EnumerateArray();
                        if (recordArray.Any())
                        {
                            var options = new JsonSerializerOptions { WriteIndented = true };
                            return JsonSerializer.Serialize(recordArray.First(), options);
                        }
                    }
                }
                catch
                {
                    // Fall through to regular extraction if JSON parsing fails
                }

                // Fallback to normal JSON extraction (object or array)
                return ExtractFirstJsonValue(text);
            }

            private static string ExtractFirstJsonValue(string text)
            {
                int objIndex = text.IndexOf('{');
                int arrIndex = text.IndexOf('[');

                int startIndex;
                char openChar;
                char closeChar;

                if (objIndex == -1 && arrIndex == -1) return null;
                if (objIndex == -1 || (arrIndex != -1 && arrIndex < objIndex))
                {
                    startIndex = arrIndex;
                    openChar = '['; closeChar = ']';
                }
                else
                {
                    startIndex = objIndex;
                    openChar = '{'; closeChar = '}';
                }

                return ExtractBalanced(text, startIndex, openChar, closeChar);
            }

            private static string ExtractBalanced(string text, int startIndex, char openChar, char closeChar)
            {
                int balance = 0;
                bool inQuotes = false;
                bool escaped = false;

                for (int i = startIndex; i < text.Length; i++)
                {
                    char c = text[i];

                    if (escaped)
                    {
                        escaped = false;
                        continue;
                    }

                    if (c == '\\')
                    {
                        escaped = true;
                        continue;
                    }

                    if (c == '"')
                    {
                        inQuotes = !inQuotes;
                        continue;
                    }

                    if (inQuotes) continue;

                    if (c == openChar)
                    {
                        balance++;
                    }
                    else if (c == closeChar)
                    {
                        balance--;
                        if (balance == 0)
                        {
                            return text.Substring(startIndex, i - startIndex + 1);
                        }
                    }
                }

                return null;
            }

            public static string NormalizeJson(string jsonText)
            {
                try
                {
                    // First, try to extract Converse-style content: output.message.content[0].text
                    try
                    {
                        using var root = JsonDocument.Parse(jsonText);
                        if (root.RootElement.TryGetProperty("output", out var output) &&
                            output.TryGetProperty("message", out var message) &&
                            message.TryGetProperty("content", out var contentArr) &&
                            contentArr.ValueKind == JsonValueKind.Array)
                        {
                            var first = contentArr.EnumerateArray().FirstOrDefault();
                            if (first.ValueKind == JsonValueKind.Object &&
                                first.TryGetProperty("text", out var textEl) &&
                                textEl.ValueKind == JsonValueKind.String)
                            {
                                var text = textEl.GetString();
                                if (!string.IsNullOrEmpty(text))
                                {
                                    text = StripCodeFences(text);
                                    var extracted = ExtractFirstJsonValue(text);
                                    if (!string.IsNullOrEmpty(extracted))
                                    {
                                        using (JsonDocument.Parse(extracted))
                                        {
                                            return extracted;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch
                    {
                        // ignore and try other strategies
                    }

                    // Legacy content string at root
                    if (jsonText.Contains("\"content\""))
                    {
                        try
                        {
                            using var doc = JsonDocument.Parse(jsonText);
                            if (doc.RootElement.TryGetProperty("content", out var contentProp) && contentProp.ValueKind == JsonValueKind.String)
                            {
                                var content = contentProp.GetString();
                                if (!string.IsNullOrEmpty(content))
                                {
                                    var extractedJson = ExtractFirstJsonObject(content);
                                    if (!string.IsNullOrEmpty(extractedJson))
                                    {
                                        using (JsonDocument.Parse(extractedJson))
                                        {
                                            return extractedJson;
                                        }
                                    }
                                }
                            }
                        }
                        catch
                        {
                            // Fall through to normal processing if content extraction fails
                        }
                    }

                    // Try to parse as-is
                    using (JsonDocument.Parse(jsonText))
                    {
                        return jsonText;
                    }
                }
                catch
                {
                    // If parsing fails, try to extract JSON object/array from text
                    var extractedJson = ExtractFirstJsonObject(jsonText);
                    if (string.IsNullOrEmpty(extractedJson))
                    {
                        throw new JsonException($"Could not extract valid JSON from response: {jsonText}");
                    }

                    using (JsonDocument.Parse(extractedJson))
                    {
                        return extractedJson;
                    }
                }
            }

            public static string StripCodeFences(string text)
            {
                // Remove ```json ... ``` fences
                if (text.StartsWith("```"))
                {
                    // Trim leading fence
                    int firstNewLine = text.IndexOf('\n');
                    if (firstNewLine > 0)
                    {
                        text = text.Substring(firstNewLine + 1);
                    }
                    // Trim trailing fence
                    int lastFence = text.LastIndexOf("```", StringComparison.Ordinal);
                    if (lastFence > 0)
                    {
                        text = text.Substring(0, lastFence);
                    }
                }
                return text.Trim();
            }
        }

        public async Task<(string response, int inputTokens, int outputTokens)> ProcessTextractResults(SimplifiedTextractResponse textractResults, string targetSchema, ILambdaContext context = null)
        {
            try
            {
                if (textractResults == null) throw new ArgumentNullException(nameof(textractResults));
                if (string.IsNullOrWhiteSpace(targetSchema)) throw new ArgumentException("Target schema cannot be empty", nameof(targetSchema));

                var requestId = context?.AwsRequestId ?? Guid.NewGuid().ToString();
                context?.Logger.LogLine($"[RequestId: {requestId}] Starting Textract processing");

                // Generate prompt
                var prompt = CreatePrompt(textractResults, targetSchema);

                // Calculate cache key based on prompt
                var promptCacheKey = $"{PROMPT_CACHE_PREFIX}{CalculateHash(prompt)}";

                context?.Logger.LogLine($"[RequestId: {requestId}] Generated prompt cache key: {promptCacheKey}");
                context?.Logger.LogLine($"[RequestId: {requestId}] Prompt hash based on {prompt.Length} characters");

                // Try to get from prompt cache first
                if (_cache.TryGetValue<CachedResponse>(promptCacheKey, out var promptCachedResponse))
                {
                    context?.Logger.LogLine($"[RequestId: {requestId}] ✓ Prompt cache HIT - returning cached response");
                    context?.Logger.LogLine($"[RequestId: {requestId}] Cache entry age: {(DateTime.UtcNow - promptCachedResponse.CachedAt).TotalMinutes:F2} minutes");
                    return (promptCachedResponse.Response, promptCachedResponse.InputTokens, promptCachedResponse.OutputTokens);
                }

                context?.Logger.LogLine($"[RequestId: {requestId}] ✗ Prompt cache MISS");

                // If not in prompt cache, check document cache
                var docCacheKey = CalculateHash(JsonSerializer.Serialize(textractResults) + targetSchema + _modelConfig.ModelId);
                context?.Logger.LogLine($"[RequestId: {requestId}] Generated document cache key: {docCacheKey}");

                if (_cache.TryGetValue<CachedResponse>(docCacheKey, out var docCachedResponse))
                {
                    context?.Logger.LogLine($"[RequestId: {requestId}] ✓ Document cache HIT - returning cached response");
                    // Store in prompt cache for future use
                    _cache.Set(promptCacheKey, docCachedResponse, TimeSpan.FromMinutes(CACHE_DURATION_MINUTES));
                    context?.Logger.LogLine($"[RequestId: {requestId}] Copied to prompt cache");
                    return (docCachedResponse.Response, docCachedResponse.InputTokens, docCachedResponse.OutputTokens);
                }

                context?.Logger.LogLine($"[RequestId: {requestId}] ✗ Document cache MISS");
                context?.Logger.LogLine($"[RequestId: {requestId}] Cache miss - processing with Bedrock");
                context?.Logger.LogLine($"[RequestId: {requestId}] Invoking Bedrock model {_modelConfig.ModelId}");

                // Create model-specific request
                var request = CreateModelRequest(prompt);
                var requestOptions = GetRequestSerializerOptions();
                var requestJson = JsonSerializer.Serialize(request, requestOptions);
                context?.Logger.LogLine($"[RequestId: {requestId}] Request JSON: {requestJson}");

                var modelRequest = new InvokeModelRequest
                {
                    ModelId = _modelConfig.ModelId,
                    ContentType = "application/json",
                    Accept = "application/json",
                    Body = new MemoryStream(Encoding.UTF8.GetBytes(requestJson))
                };

                context?.Logger.LogLine($"[RequestId: {requestId}] Sending request to Bedrock");
                var startTime = DateTime.UtcNow;
                var response = await _bedrockClient.InvokeModelAsync(modelRequest);
                var duration = DateTime.UtcNow - startTime;
                context?.Logger.LogLine($"[RequestId: {requestId}] Bedrock response received in {duration.TotalMilliseconds:F0}ms");

                // Read and parse response
                string responseJson;
                using (var ms = new MemoryStream())
                {
                    await response.Body.CopyToAsync(ms);
                    ms.Position = 0;
                    using var reader = new StreamReader(ms);
                    responseJson = await reader.ReadToEndAsync();
                }

                // First, try to extract completion text and save clean JSON derived from it
                var completionText = TryExtractCompletionText(responseJson);
                if (!string.IsNullOrWhiteSpace(completionText))
                {
                    await SaveCompletionArtifacts(completionText, requestId, context);
                }

                // Log full response to files (raw + normalized best-effort)
                await SaveResponseToFile(responseJson, requestId, context);

                var (outputText, inputTokens, outputTokens) = ParseResponse(responseJson);
                context?.Logger.LogLine($"[RequestId: {requestId}] Processing metrics:" +
                                        $"\n- Input tokens: {inputTokens}" +
                                        $"\n- Output tokens: {outputTokens}" +
                                        $"\n- Response size: {outputText.Length} chars");

                var cacheEntry = new CachedResponse
                {
                    Response = outputText,
                    InputTokens = inputTokens,
                    OutputTokens = outputTokens
                };

                // Cache response with both keys
                _cache.Set(docCacheKey, cacheEntry, TimeSpan.FromMinutes(CACHE_DURATION_MINUTES));
                _cache.Set(promptCacheKey, cacheEntry, TimeSpan.FromMinutes(CACHE_DURATION_MINUTES));

                context?.Logger.LogLine($"[RequestId: {requestId}] ✓ Response cached successfully");
                context?.Logger.LogLine($"[RequestId: {requestId}] - Document cache key: {docCacheKey}");
                context?.Logger.LogLine($"[RequestId: {requestId}] - Prompt cache key: {promptCacheKey}");
                context?.Logger.LogLine($"[RequestId: {requestId}] - Cache duration: {CACHE_DURATION_MINUTES} minutes");
                context?.Logger.LogLine($"[RequestId: {requestId}] - Cache entry created at: {cacheEntry.CachedAt:yyyy-MM-dd HH:mm:ss} UTC");

                return (outputText, inputTokens, outputTokens);
            }
            catch (Exception e)
            {
                context?.Logger.LogLine($"Error in Bedrock service: {e.Message}\nStack trace: {e.StackTrace}");
                throw;
            }
        }

        private JsonSerializerOptions GetRequestSerializerOptions()
        {
            // Titan must preserve exact camelCase keys; Nova/Claude are already using exact identifiers.
            return _modelConfig.RequestFormat switch
            {
                Models.RequestFormat.Titan => new JsonSerializerOptions
                {
                    PropertyNamingPolicy = null,
                    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
                },
                Models.RequestFormat.Nova => new JsonSerializerOptions
                {
                    PropertyNamingPolicy = null,
                    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
                },
                Models.RequestFormat.Claude => new JsonSerializerOptions
                {
                    PropertyNamingPolicy = null,
                    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
                },
                _ => new JsonSerializerOptions
                {
                    PropertyNamingPolicy = null,
                    DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
                }
            };
        }

        private static string TryExtractCompletionText(string responseJson)
        {
            try
            {
                using var doc = JsonDocument.Parse(responseJson);

                // Qwen style: choices[0].message.content (at root level)
                if (doc.RootElement.TryGetProperty("choices", out var qwenChoices) &&
                    qwenChoices.ValueKind == JsonValueKind.Array)
                {
                    var firstChoice = qwenChoices.EnumerateArray().FirstOrDefault();
                    if (firstChoice.ValueKind == JsonValueKind.Object &&
                        firstChoice.TryGetProperty("message", out var qwenMessage) &&
                        qwenMessage.TryGetProperty("content", out var qwenContent) &&
                        qwenContent.ValueKind == JsonValueKind.String)
                    {
                        return qwenContent.GetString();
                    }
                }

                // Converse output style: output.message.content[0].text
                if (doc.RootElement.TryGetProperty("output", out var output) &&
                    output.TryGetProperty("message", out var message) &&
                    message.TryGetProperty("content", out var contentArr) &&
                    contentArr.ValueKind == JsonValueKind.Array)
                {
                    foreach (var item in contentArr.EnumerateArray())
                    {
                        if (item.ValueKind == JsonValueKind.Object && item.TryGetProperty("text", out var textEl) && textEl.ValueKind == JsonValueKind.String)
                        {
                            var text = textEl.GetString();
                            if (!string.IsNullOrWhiteSpace(text))
                            {
                                return text;
                            }
                        }
                    }
                }

                // Titan style: results[0].outputText
                if (doc.RootElement.TryGetProperty("results", out var results) && results.ValueKind == JsonValueKind.Array)
                {
                    var first = results.EnumerateArray().FirstOrDefault();
                    if (first.ValueKind == JsonValueKind.Object && first.TryGetProperty("outputText", out var ot) && ot.ValueKind == JsonValueKind.String)
                    {
                        return ot.GetString();
                    }
                }

                // Claude style: content string
                if (doc.RootElement.TryGetProperty("content", out var contentProp) && contentProp.ValueKind == JsonValueKind.String)
                {
                    return contentProp.GetString();
                }

                // Generic completion field
                if (doc.RootElement.TryGetProperty("completion", out var comp) && comp.ValueKind == JsonValueKind.String)
                {
                    return comp.GetString();
                }
            }
            catch
            {
                // ignore and return null below
            }
            return null;
        }

        private static async Task SaveCompletionArtifacts(string completionText, string requestId, ILambdaContext context)
        {
            try
            {
                var outputPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "CachedFiles_OutputFiles");
                Directory.CreateDirectory(outputPath);

                // Save raw completion text
                var rawTextFile = $"completion_text_{DateTime.UtcNow:yyyyMMdd_HHmmss}_{requestId}.txt";
                await File.WriteAllTextAsync(Path.Combine(outputPath, rawTextFile), completionText);

                // Strip code fences then try to normalize JSON from completion text
                var stripped = JsonExtractor.StripCodeFences(completionText);
                try
                {
                    var normalized = JsonExtractor.NormalizeJson(stripped);
                    using var doc = JsonDocument.Parse(normalized);
                    var options = new JsonSerializerOptions { WriteIndented = true };
                    var pretty = JsonSerializer.Serialize(doc.RootElement, options);

                    var jsonFile = $"completion_json_{DateTime.UtcNow:yyyyMMdd_HHmms}_{requestId}.json";
                    await File.WriteAllTextAsync(Path.Combine(outputPath, jsonFile), pretty);

                    context?.Logger.LogLine($"Saved completion artifacts: {rawTextFile}, {jsonFile}");
                }
                catch (Exception jsonEx)
                {
                    context?.Logger.LogLine($"Could not parse completion JSON: {jsonEx.Message}");
                }
            }
            catch (Exception ex)
            {
                context?.Logger.LogLine($"Warning saving completion artifacts: {ex.Message}");
            }
        }

        private static async Task SaveResponseToFile(string responseJson, string requestId, ILambdaContext context)
        {
            try
            {
                var outputPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "CachedFiles_OutputFiles");
                Directory.CreateDirectory(outputPath);

                var rawFileName = $"raw_response_{DateTime.UtcNow:yyyyMMdd_HHmms}_{requestId}.txt";
                await File.WriteAllTextAsync(Path.Combine(outputPath, rawFileName), responseJson);

                try
                {
                    var normalizedJson = JsonExtractor.NormalizeJson(responseJson);
                    using var doc = JsonDocument.Parse(normalizedJson);
                    var element = doc.RootElement;

                    var options = new JsonSerializerOptions { WriteIndented = true };
                    var prettyJson = JsonSerializer.Serialize(element, options);

                    var jsonFileName = $"formatted_response_{DateTime.UtcNow:yyyyMMdd_HHmms}_{requestId}.json";
                    await File.WriteAllTextAsync(Path.Combine(outputPath, jsonFileName), prettyJson);

                    context?.Logger.LogLine($"Response saved to {rawFileName} and {jsonFileName}");
                }
                catch (Exception jsonEx)
                {
                    context?.Logger.LogLine($"Warning: Could not format JSON response: {jsonEx.Message}");
                }
            }
            catch (Exception ex)
            {
                context?.Logger.LogLine($"Warning: Could not save response to file: {ex.Message}");
            }
        }

        private (string outputText, int inputTokens, int outputTokens) ParseResponse(string responseJson)
        {
            try
            {
                // Normalize JSON before parsing where appropriate for content-only expectations
                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };

                return _modelConfig.ResponseFormat switch
                {
                    Models.ResponseFormat.Titan => ParseTitanResponse(JsonExtractor.NormalizeJson(responseJson), options),
                    Models.ResponseFormat.Nova => ParseNovaResponse(responseJson, options),
                    Models.ResponseFormat.Claude => ParseClaudeResponse(JsonExtractor.NormalizeJson(responseJson), options),
                    Models.ResponseFormat.Qwen => ParseQwenResponse(responseJson, options),
                    _ => throw new ArgumentException($"Unsupported response format: {_modelConfig.ResponseFormat}")
                };
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"Failed to parse response: {ex.Message}\nResponse: {responseJson}", ex);
            }
        }

        private static (string, int, int) ParseTitanResponse(string responseJson, JsonSerializerOptions options)
        {
            var response = JsonSerializer.Deserialize<TitanResponse>(responseJson, options);
            if (response?.Results == null || response.Results.Count == 0)
            {
                throw new InvalidOperationException($"Invalid Titan response format: {responseJson}");
            }

            return (
        response.Results[0].OutputText,
      response.Results[0].InputTextTokenCount,
            response.Results[0].OutputTextTokenCount
          );
        }

        private static (string, int, int) ParseClaudeResponse(string responseJson, JsonSerializerOptions options)
        {
            var response = JsonSerializer.Deserialize<ClaudeResponse>(responseJson, options);
            return (
 response?.Content ?? string.Empty,
     response?.Usage?.InputTokens ?? EstimateTokenCount(responseJson),
      response?.Usage?.OutputTokens ?? EstimateTokenCount(response?.Content)
            );
        }

        private static (string, int, int) ParseQwenResponse(string responseJson, JsonSerializerOptions options)
        {
            var response = JsonSerializer.Deserialize<QwenChatResponse>(responseJson, options);
            var outputText = response?.Choices?.FirstOrDefault()?.Message?.Content ?? string.Empty;
            var inputTokens = response?.Usage?.PromptTokens ?? 0;
            var outputTokens = response?.Usage?.CompletionTokens ?? 0;

            return (outputText, inputTokens, outputTokens);
        }

        private static (string, int, int) ParseNovaResponse(string responseJson, JsonSerializerOptions options)
        {
            // Extract the model completion text and then extract JSON from within it
            var text = TryExtractCompletionText(responseJson);
            if (!string.IsNullOrWhiteSpace(text))
            {
                text = JsonExtractor.StripCodeFences(text);
                var extracted = JsonExtractor.ExtractFirstJsonObject(text) ?? text;
                // If extracted looks like JSON, keep as-is; otherwise return raw text
                try
                {
                    using (JsonDocument.Parse(extracted)) { /* ok */ }
                    return (extracted, EstimateTokenCount(responseJson), EstimateTokenCount(extracted));
                }
                catch
                {
                    return (text, EstimateTokenCount(responseJson), EstimateTokenCount(text));
                }
            }

            // Fallback: normalize entire response
            var normalized = JsonExtractor.NormalizeJson(responseJson);
            return (normalized, EstimateTokenCount(responseJson), EstimateTokenCount(normalized));
        }

        private static string CreatePrompt(SimplifiedTextractResponse textractResults, string targetSchema)
        {
            // Ensure we have data to process
            if (string.IsNullOrEmpty(textractResults.RawText))
            {
                throw new ArgumentException("No raw text available in the textract results to process");
            }

            // Use only the RawText for the source data to keep the prompt focused and small.
            var sourceData = textractResults.RawText;
            var fewShotExamples = GetFewShotExamples();

            return $@"Transform the following source data into a JSON object that matches the target schema structure.

{fewShotExamples}

Source Data:
{sourceData}

Target Schema:
{targetSchema}

CRITICAL RULES - READ CAREFULLY:
1. Data Types & Formats:
   - Use proper data types (numbers without quotes, strings with quotes)
   - Use YYYY-MM-DD format for all dates
   - Use null for unmapped required fields
   - Match property names exactly as shown in schema

2. Owner/Buyer Handling Rules:
   - If multiple owners/buyers are mentioned, create separate entries for EACH person
   - ALWAYS distribute ownership percentages equally among all owners
   - Example: 2 owners = 50% each, 3 owners = 33.33% each, 4 owners = 25% each
   - Formula: buyerPercentage = 100 / (total number of buyers)
   - Set buyerIsPrimary = true for the FIRST buyer only, false for all others
   - Include BOTH old owners (grantors) and new owners (grantees) in their respective arrays

3. Name Parsing Rules:
   - Extract first, middle, and last names separately when available
   - If only full name is available, parse it intelligently:
   * First word = firstName
     * Last word = lastName
     * Middle words = middleName
   - Preserve original vesting/title information exactly as written

4. Multiple Entries:
   - For buyer_names_component array: Create one object per buyer/owner
   - For oldOwners array: Create one object per previous owner
   - Never combine multiple people into a single entry
   - Each person must have their own complete object with all fields

5. Validation Checklist Before Returning:
   - Count total owners mentioned in source data
   - Verify you created that many entries in the array
   - Verify percentage split: (number of entries × each percentage) = 100
   - Verify first entry has buyerIsPrimary: true
   - Verify remaining entries have buyerIsPrimary: false

EXAMPLES:
Source: ""John Smith and Mary Johnson""
Correct Output:
[
  {{""firstName"": ""John"", ""lastName"": ""Smith"", ""buyerPercentage"": 50, ""buyerIsPrimary"": true}},
  {{""firstName"": ""Mary"", ""lastName"": ""Johnson"", ""buyerPercentage"": 50, ""buyerIsPrimary"": false}}
]

Source: ""Charles D. Shapiro and Suzanne D. Shapiro""
Correct Output:
[
  {{""firstName"": ""Charles"", ""middleName"": ""D."", ""lastName"": ""Shapiro"", ""buyerPercentage"": 50, ""buyerIsPrimary"": true}},
  {{""firstName"": ""Suzanne"", ""middleName"": ""D."", ""lastName"": ""Shapiro"", ""buyerPercentage"": 50, ""buyerIsPrimary"": false}}
]

Output Format: Return ONLY the complete Target Schema JSON with NO additional text, explanations, or markdown formatting.";
        }

        private static string GetFewShotExamples()
        {
          return @"LEARNING EXAMPLES - Study these before processing:

Example 1:
Input: ""GRANT DEED from Michael Johnson and Sarah Johnson, husband and wife as joint tenants to Michael Johnson and Sarah Johnson as trustees of the Johnson Family Trust""
Output for buyer_names_component:
[
  {
    ""firstName"": ""Michael"",
    ""lastName"": ""Johnson"",
    ""buyerVesting"": ""AS TRUSTEES OF THE JOHNSON FAMILY TRUST"",
    ""buyerPercentage"": 50,
    ""buyerIsPrimary"": true
  },
  {
    ""firstName"": ""Sarah"",
    ""lastName"": ""Johnson"",
    ""buyerVesting"": ""AS TRUSTEES OF THE JOHNSON FAMILY TRUST"",
    ""buyerPercentage"": 50,
    ""buyerIsPrimary"": false
  }
]

Example 2:
Input: ""Previous owners: Robert E. Williams and Elizabeth A. Williams""
Output for oldOwners:
[
  {
    ""firstName"": ""Robert"",
    ""middleName"": ""E."",
    ""lastName"": ""Williams"",
    ""percentage"": 50,
    ""principal"": true
  },
  {
    ""firstName"": ""Elizabeth"",
    ""middleName"": ""A."",
    ""lastName"": ""Williams"",
    ""percentage"": 50,
    ""principal"": false
  }
]

Example 3 - Three Owners:
Input: ""David Chen, Lisa Martinez, and James Brown as joint tenants""
Output:
[
  {""firstName"": ""David"", ""lastName"": ""Chen"", ""buyerPercentage"": 33.33, ""buyerIsPrimary"": true},
  {""firstName"": ""Lisa"", ""lastName"": ""Martinez"", ""buyerPercentage"": 33.33, ""buyerIsPrimary"": false},
  {""firstName"": ""James"", ""lastName"": ""Brown"", ""buyerPercentage"": 33.34, ""buyerIsPrimary"": false}
]

Note: In Example 3, the last owner gets 33.34% to ensure total = 100%

---END OF EXAMPLES---
";
        }

        private object CreateModelRequest(string prompt)
        {
            return _modelConfig.RequestFormat switch
            {
                Models.RequestFormat.Titan => new
                {
                    inputText = prompt,
                    textGenerationConfig = new
                    {
                        maxTokenCount = _modelConfig.InferenceParameters.MaxTokens,
                        temperature = _modelConfig.InferenceParameters.Temperature,
                        topP = _modelConfig.InferenceParameters.TopP,
                        stopSequences = _modelConfig.InferenceParameters.StopSequences ?? Array.Empty<string>()
                    }
                },
                Models.RequestFormat.Nova => new
                {
                    messages = new[]
                    {
                              new
                                 {
                             role = "user",
                               content = new[] { new { text = prompt } }
                                  }
                                    }
                },
                Models.RequestFormat.Claude => new
                {
                    anthropic_version = _modelConfig.InferenceParameters.Version,
                    system = _modelConfig.SystemPrompt,
                    max_tokens = _modelConfig.InferenceParameters.MaxTokens,
                    temperature = _modelConfig.InferenceParameters.Temperature,
                    top_p = _modelConfig.InferenceParameters.TopP,
                    messages = new[]
                       {
                        new { role = "user", content = prompt }
                                 }
                },
                Models.RequestFormat.Qwen => new
                {
                    messages = new[]
                    {
                        new { role = "system", content = _modelConfig.SystemPrompt },
                        new { role = "user", content = prompt }
                    },
                    top_p = _modelConfig.InferenceParameters.TopP,
                    temperature = _modelConfig.InferenceParameters.Temperature,
                    max_tokens = _modelConfig.InferenceParameters.MaxTokens
                },
                _ => throw new ArgumentException($"Unsupported model format: {_modelConfig.RequestFormat}")
            };
        }

        private static string CalculateHash(string input)
        {
            using var sha256 = SHA256.Create();
            var bytes = Encoding.UTF8.GetBytes(input);
            var hash = sha256.ComputeHash(bytes);
            return Convert.ToBase64String(hash);
        }

        private static int EstimateTokenCount(string text)
        {
            return text?.Length / 4 ?? 0;
        }
    }

    // Response Models
    public class TitanResponse
    {
        public List<TitanResult> Results { get; set; } = new();
    }

    public class ClaudeResponse
    {
        public string Content { get; set; } = string.Empty;
        public Usage Usage { get; set; }
    }

    public class QwenResponse
    {
        [JsonPropertyName("output")]
        public QwenOutput Output { get; set; }
        [JsonPropertyName("usage")]
        public QwenUsage Usage { get; set; }
    }

    public class QwenChatResponse
    {
        [JsonPropertyName("choices")]
        public List<QwenChatChoice> Choices { get; set; }
        [JsonPropertyName("usage")]
        public QwenChatUsage Usage { get; set; }
    }

    public class QwenChatChoice
    {
        [JsonPropertyName("message")]
        public QwenChatMessage Message { get; set; }
        [JsonPropertyName("finish_reason")]
        public string FinishReason { get; set; }
    }

    public class QwenChatMessage
    {
        [JsonPropertyName("content")]
        public string Content { get; set; }
        [JsonPropertyName("role")]
        public string Role { get; set; }
    }

    public class QwenChatUsage
    {
        [JsonPropertyName("prompt_tokens")]
        public int PromptTokens { get; set; }
        [JsonPropertyName("completion_tokens")]
        public int CompletionTokens { get; set; }
        [JsonPropertyName("total_tokens")]
        public int TotalTokens { get; set; }
    }

    public class QwenOutput
    {
        [JsonPropertyName("choices")]
        public List<QwenChatChoice> Choices { get; set; }
    }

    public class QwenChoice
    {
        [JsonPropertyName("message")]
        public QwenMessage Message { get; set; }
        [JsonPropertyName("stop_reason")]
        public string StopReason { get; set; }
    }

    public class QwenMessage
    {
        [JsonPropertyName("content")]
        public string Content { get; set; }
    }

    public class QwenUsage
    {
        [JsonPropertyName("input_tokens")]
        public int InputTokens { get; set; }

        [JsonPropertyName("output_tokens")]
        public int OutputTokens { get; set; }
    }

    public class Usage
    {
        [JsonPropertyName("input_tokens")]
        public int InputTokens { get; set; }

        [JsonPropertyName("output_tokens")]
        public int OutputTokens { get; set; }
    }

    public class TitanResult
    {
        [JsonPropertyName("outputText")]
        public string OutputText { get; set; } = string.Empty;

        [JsonPropertyName("completionReason")]
        public string CompletionReason { get; set; } = string.Empty;

        [JsonPropertyName("inputTextTokenCount")]
        public int InputTextTokenCount { get; set; }

        [JsonPropertyName("outputTextTokenCount")]
        public int OutputTextTokenCount { get; set; }
    }

    public class CachedResponse
    {
        public string Response { get; set; } = string.Empty;
        public int InputTokens { get; set; }
        public int OutputTokens { get; set; }
        public DateTime CachedAt { get; set; } = DateTime.UtcNow;
    }
}
