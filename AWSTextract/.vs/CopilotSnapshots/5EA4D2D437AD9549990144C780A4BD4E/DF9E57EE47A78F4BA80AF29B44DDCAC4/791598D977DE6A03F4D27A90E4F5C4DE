using Amazon;
using Amazon.BedrockRuntime;
using Amazon.BedrockRuntime.Model;
using Amazon.Lambda.Core;
using Microsoft.Extensions.Caching.Memory;
using System.Security.Cryptography;
using System.Text;
using System.Text.Json;
using System.Text.Json.Serialization;
using TextractProcessor.Models;

namespace TextractProcessor.Services
{
    public class SnakeCaseNamingPolicy : JsonNamingPolicy
    {
        public override string ConvertName(string name)
        {
            if (string.IsNullOrEmpty(name)) return name;

            var builder = new StringBuilder();
            for (var i = 0; i < name.Length; i++)
            {
                if (i > 0 && char.IsUpper(name[i]))
                {
                    builder.Append('_');
                }
                builder.Append(char.ToLower(name[i]));
            }
            return builder.ToString();
        }
    }

    public class BedrockService
    {
        private readonly IAmazonBedrockRuntime _bedrockClient;
        private readonly IMemoryCache _cache;
        private readonly BedrockModelConfig _modelConfig;
        private const int CACHE_DURATION_MINUTES = 60;
        private const string PROMPT_CACHE_PREFIX = "prompt_";
        private static readonly JsonSerializerOptions _jsonOptions = new()
        {
            PropertyNamingPolicy = new SnakeCaseNamingPolicy(),
            DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
        };

        public BedrockService(IAmazonBedrockRuntime bedrockClient, IMemoryCache cache, BedrockModelConfig modelConfig = null)
        {
            // Create new client with US East 1 region
            _bedrockClient = new AmazonBedrockRuntimeClient(RegionEndpoint.USEast1);
            _cache = cache ?? throw new ArgumentNullException(nameof(cache));
            _modelConfig = modelConfig ?? BedrockModelConfig.NovaLite;
        }

        private static class JsonExtractor
        {
            public static string ExtractFirstJsonObject(string text)
            {
                int startIndex = text.IndexOf('{');
                if (startIndex == -1) return null;

                int balance = 0;
                bool inQuotes = false;
                bool escaped = false;

                for (int i = startIndex; i < text.Length; i++)
                {
                    char c = text[i];

                    if (escaped)
                    {
                        escaped = false;
                        continue;
                    }

                    if (c == '\\')
                    {
                        escaped = true;
                        continue;
                    }

                    if (c == '"')
                    {
                        inQuotes = !inQuotes;
                        continue;
                    }

                    if (inQuotes) continue;

                    if (c == '{')
                    {
                        balance++;
                    }
                    else if (c == '}')
                    {
                        balance--;
                        if (balance == 0)
                        {
                            return text.Substring(startIndex, i - startIndex + 1);
                        }
                    }
                }

                return null;
            }

            public static string NormalizeJson(string jsonText)
            {
                try
                {
                    using (JsonDocument.Parse(jsonText))
                    {
                        return jsonText;
                    }
                }
                catch
                {
                    var extractedJson = ExtractFirstJsonObject(jsonText);
                    if (string.IsNullOrEmpty(extractedJson))
                    {
                        throw new JsonException($"Could not extract valid JSON from response: {jsonText}");
                    }

                    using (JsonDocument.Parse(extractedJson))
                    {
                        return extractedJson;
                    }
                }
            }
        }

        public async Task<(string response, int inputTokens, int outputTokens)> ProcessTextractResults(SimplifiedTextractResponse textractResults, string targetSchema, ILambdaContext context = null)
        {
            try
            {
                if (textractResults == null) throw new ArgumentNullException(nameof(textractResults));
                if (string.IsNullOrWhiteSpace(targetSchema)) throw new ArgumentException("Target schema cannot be empty", nameof(targetSchema));

                var requestId = context?.AwsRequestId ?? Guid.NewGuid().ToString();
                context?.Logger.LogLine($"[RequestId: {requestId}] Starting Textract processing");

                // Generate prompt
                var prompt = CreatePrompt(textractResults, targetSchema);

                // Calculate cache key based on prompt
                var promptCacheKey = $"{PROMPT_CACHE_PREFIX}{CalculateHash(prompt)}";

                // Try to get from prompt cache first
                if (_cache.TryGetValue<CachedResponse>(promptCacheKey, out var promptCachedResponse))
                {
                    context?.Logger.LogLine($"[RequestId: {requestId}] Prompt cache hit - returning cached response");
                    return (promptCachedResponse.Response, promptCachedResponse.InputTokens, promptCachedResponse.OutputTokens);
                }

                // If not in prompt cache, check document cache
                var docCacheKey = CalculateHash(JsonSerializer.Serialize(textractResults) + targetSchema + _modelConfig.ModelId);
                if (_cache.TryGetValue<CachedResponse>(docCacheKey, out var docCachedResponse))
                {
                    context?.Logger.LogLine($"[RequestId: {requestId}] Document cache hit - returning cached response");
                    // Store in prompt cache for future use
                    _cache.Set(promptCacheKey, docCachedResponse, TimeSpan.FromMinutes(CACHE_DURATION_MINUTES));
                    return (docCachedResponse.Response, docCachedResponse.InputTokens, docCachedResponse.OutputTokens);
                }

                context?.Logger.LogLine($"[RequestId: {requestId}] Cache miss - processing with Bedrock");
                context?.Logger.LogLine($"[RequestId: {requestId}] Invoking Bedrock model {_modelConfig.ModelId}");

                // Create model-specific request
                var request = CreateModelRequest(prompt);
                var requestJson = JsonSerializer.Serialize(request, _jsonOptions);
                context?.Logger.LogLine($"[RequestId: {requestId}] Request JSON: {requestJson}");

                var modelRequest = new InvokeModelRequest
                {
                    ModelId = "amazon.nova-lite-v1:0",
                    ContentType = "application/json",
                    Accept = "application/json",
                    Body = new MemoryStream(Encoding.UTF8.GetBytes(requestJson))
                };

                context?.Logger.LogLine($"[RequestId: {requestId}] Sending request to Bedrock");
                var startTime = DateTime.UtcNow;
                var response = await _bedrockClient.InvokeModelAsync(modelRequest);
                var duration = DateTime.UtcNow - startTime;
                context?.Logger.LogLine($"[RequestId: {requestId}] Bedrock response received in {duration.TotalMilliseconds:F0}ms");

                // Read and parse response
                string responseJson;
                using (var ms = new MemoryStream())
                {
                    await response.Body.CopyToAsync(ms);
                    ms.Position = 0;
                    using var reader = new StreamReader(ms);
                    responseJson = await reader.ReadToEndAsync();
                }

                // Log response to file
                await SaveResponseToFile(responseJson, requestId, context);

                var (outputText, inputTokens, outputTokens) = ParseResponse(responseJson);
                context?.Logger.LogLine($"[RequestId: {requestId}] Processing metrics:" +
                                        $"\n- Input tokens: {inputTokens}" +
                                        $"\n- Output tokens: {outputTokens}" +
                                        $"\n- Response size: {outputText.Length} chars");

                var cacheEntry = new CachedResponse
                {
                    Response = outputText,
                    InputTokens = inputTokens,
                    OutputTokens = outputTokens
                };

                // Cache response with both keys
                _cache.Set(docCacheKey, cacheEntry, TimeSpan.FromMinutes(CACHE_DURATION_MINUTES));
                _cache.Set(promptCacheKey, cacheEntry, TimeSpan.FromMinutes(CACHE_DURATION_MINUTES));

                context?.Logger.LogLine($"[RequestId: {requestId}] Response cached with keys: {docCacheKey}, {promptCacheKey}");

                return (outputText, inputTokens, outputTokens);
            }
            catch (Exception e)
            {
                context?.Logger.LogLine($"Error in Bedrock service: {e.Message}\nStack trace: {e.StackTrace}");
                throw;
            }
        }

        private static async Task SaveResponseToFile(string responseJson, string requestId, ILambdaContext context)
        {
            try
            {
                var outputPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "bedrock_responses");
                Directory.CreateDirectory(outputPath);

                var rawFileName = $"raw_response_{DateTime.UtcNow:yyyyMMdd_HHmmss}_{requestId}.txt";
                await File.WriteAllTextAsync(Path.Combine(outputPath, rawFileName), responseJson);

                try
                {
                    var normalizedJson = JsonExtractor.NormalizeJson(responseJson);
                    using var doc = JsonDocument.Parse(normalizedJson);
                    var element = doc.RootElement;

                    var options = new JsonSerializerOptions { WriteIndented = true };
                    var prettyJson = JsonSerializer.Serialize(element, options);

                    var jsonFileName = $"formatted_response_{DateTime.UtcNow:yyyyMMdd_HHmms}_{requestId}.json";
                    await File.WriteAllTextAsync(Path.Combine(outputPath, jsonFileName), prettyJson);

                    context?.Logger.LogLine($"Response saved to {rawFileName} and {jsonFileName}");
                }
                catch (Exception jsonEx)
                {
                    context?.Logger.LogLine($"Warning: Could not format JSON response: {jsonEx.Message}");
                }
            }
            catch (Exception ex)
            {
                context?.Logger.LogLine($"Warning: Could not save response to file: {ex.Message}");
            }
        }

        private (string outputText, int inputTokens, int outputTokens) ParseResponse(string responseJson)
        {
            try
            {
                // Normalize JSON before parsing
                var normalizedJson = JsonExtractor.NormalizeJson(responseJson);

                var options = new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true
                };

                return _modelConfig.ResponseFormat switch
                {
                    Models.ResponseFormat.Titan => ParseTitanResponse(normalizedJson, options),
                    Models.ResponseFormat.Nova => ParseTitanResponse(normalizedJson, options),
                    Models.ResponseFormat.Claude => ParseClaudeResponse(normalizedJson, options),
                    _ => throw new ArgumentException($"Unsupported response format: {_modelConfig.ResponseFormat}")
                };
            }
            catch (Exception ex)
            {
                throw new InvalidOperationException($"Failed to parse response: {ex.Message}\nResponse: {responseJson}", ex);
            }
        }

        private static (string, int, int) ParseTitanResponse(string responseJson, JsonSerializerOptions options)
        {
            var response = JsonSerializer.Deserialize<TitanResponse>(responseJson, options);
            if (response?.Results == null || response.Results.Count == 0)
            {
                throw new InvalidOperationException($"Invalid Titan response format: {responseJson}");
            }

            return (
        response.Results[0].OutputText,
      response.Results[0].InputTextTokenCount,
            response.Results[0].OutputTextTokenCount
          );
        }

        private static (string, int, int) ParseClaudeResponse(string responseJson, JsonSerializerOptions options)
        {
            var response = JsonSerializer.Deserialize<ClaudeResponse>(responseJson, options);
            return (
 response?.Content ?? string.Empty,
     response?.Usage?.InputTokens ?? EstimateTokenCount(responseJson),
      response?.Usage?.OutputTokens ?? EstimateTokenCount(response?.Content)
            );
        }

        private static string CreatePrompt(SimplifiedTextractResponse textractResults, string targetSchema)
        {
            // Ensure we have data to process
            if (string.IsNullOrEmpty(textractResults.RawText) &&
  (textractResults.FormFields == null || !textractResults.FormFields.Any()) &&
    (textractResults.TableData == null || !textractResults.TableData.Any()))
            {
                throw new ArgumentException("No data available in the textract results to process");
            }

            // Serialize the source data
            var sourceData = JsonSerializer.Serialize(textractResults, new JsonSerializerOptions
            {
                WriteIndented = true,
                DefaultIgnoreCondition = JsonIgnoreCondition.WhenWritingNull
            });

            return $@"Transform the following source data into a JSON object that matches the target schema structure.

Source Data:
{sourceData}

Target Schema:
{targetSchema}

Rules:
- Create a valid JSON object
- Use proper data types (numbers without quotes, strings with quotes)
- Use YYYY-MM-DD for dates
- Use null for unmapped required fields
- Match property names exactly
- Return only the JSON object

Output Format: Return a valid JSON object only, no additional text or explanations.";
        }

        private static object CreateModelRequest(string prompt)
        {
            return _modelConfig.RequestFormat switch
 {
        Models.RequestFormat.Titan => new
        {
            inputText = prompt,
        textGenerationConfig = new
            {
                maxTokenCount = _modelConfig.MaxTokens,
         temperature = _modelConfig.Temperature,
      topP = _modelConfig.TopP,
     stopSequences = _modelConfig.StopSequences ?? Array.Empty<string>()
          }
        },
        Models.RequestFormat.Nova => new
        {
            messages = new[]
            {
  new
     {
 role = "user",
   content = new[] { new { text = prompt } }
      }
            }
        },
  Models.RequestFormat.Claude => new
  {
       anthropic_version = _modelConfig.Version,
         max_tokens = _modelConfig.MaxTokens,
      temperature = _modelConfig.Temperature,
            messages = new[]
         {
new { role = "user", content = prompt }
         }
      },
        _ => throw new ArgumentException($"Unsupported model format: {_modelConfig.RequestFormat}")
    };
        }

        private static string CalculateHash(string input)
        {
            using var sha256 = SHA256.Create();
            var bytes = Encoding.UTF8.GetBytes(input);
            var hash = sha256.ComputeHash(bytes);
            return Convert.ToBase64String(hash);
        }

        private static int EstimateTokenCount(string text)
        {
            return text?.Length / 4 ?? 0;
        }
    }

    // Response Models
    public class NovaResponse
    {
        public string Content { get; set; } = string.Empty;
        public Usage Usage { get; set; }
    }

    public class TitanResponse
    {
        public List<TitanResult> Results { get; set; } = new();
    }

    public class ClaudeResponse
    {
        public string Content { get; set; } = string.Empty;
        public Usage Usage { get; set; }
    }

    public class Usage
    {
        [JsonPropertyName("input_tokens")]
        public int InputTokens { get; set; }

        [JsonPropertyName("output_tokens")]
        public int OutputTokens { get; set; }
    }

    public class TitanResult
    {
        [JsonPropertyName("outputText")]
        public string OutputText { get; set; } = string.Empty;

        [JsonPropertyName("completionReason")]
        public string CompletionReason { get; set; } = string.Empty;

        [JsonPropertyName("inputTextTokenCount")]
        public int InputTextTokenCount { get; set; }

        [JsonPropertyName("outputTextTokenCount")]
        public int OutputTextTokenCount { get; set; }
    }

    public class CachedResponse
    {
        public string Response { get; set; } = string.Empty;
        public int InputTokens { get; set; }
        public int OutputTokens { get; set; }
        public DateTime CachedAt { get; set; } = DateTime.UtcNow;
    }
}