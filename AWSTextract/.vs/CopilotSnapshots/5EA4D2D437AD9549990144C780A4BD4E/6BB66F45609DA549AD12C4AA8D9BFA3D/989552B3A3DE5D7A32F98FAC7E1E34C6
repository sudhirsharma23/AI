using System.Text.Json;
using Microsoft.Extensions.Caching.Memory;
using System.Reflection;
using TextractProcessor.Models;
using System.Text.Json.Nodes;

namespace TextractProcessor.Services
{
    public class SchemaMapperService
    {
        private readonly BedrockService _bedrockService;
        private readonly IMemoryCache _cache;
        private readonly string _outputDirectory;
        private readonly string _schemaFilePath;

        public SchemaMapperService(BedrockService bedrockService, IMemoryCache cache, string outputDirectory)
        {
            _bedrockService = bedrockService;
            _cache = cache;
            _outputDirectory = outputDirectory;

            // Get the directory where the application is running
            var baseDirectory = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            _schemaFilePath = Path.Combine(baseDirectory!, "invoice_schema.json");

            // Ensure the schema file exists in the output directory
            if (!File.Exists(_schemaFilePath))
            {
                var sourceSchemaPath = Path.Combine(
                    Directory.GetCurrentDirectory(),
                          "invoice_schema.json");

                if (File.Exists(sourceSchemaPath))
                {
                    File.Copy(sourceSchemaPath, _schemaFilePath, true);
                }
                else
                {
                    throw new FileNotFoundException(
                            $"Schema file not found at either {_schemaFilePath} or {sourceSchemaPath}. " +
                     $"Please ensure invoice_schema.json is present in the project directory.");
                }
            }
        }

        public async Task<ProcessingResult> ProcessAndMapSchema(
            SimplifiedTextractResponse textractResults,
       string schemaFilePath,
            string originalFileName)
        {
            try
            {
                // Use the resolved schema path instead of the parameter
                var targetSchema = await File.ReadAllTextAsync(_schemaFilePath);

                var (mappedJson, inputTokens, outputTokens) = await _bedrockService.ProcessTextractResults(
           textractResults,
              targetSchema
          );

                // Validate and clean the JSON response
                var cleanedJson = await ValidateAndCleanJson(mappedJson);

                var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
                var baseFileName = Path.GetFileNameWithoutExtension(originalFileName);
                var mappedFilePath = Path.Combine(_outputDirectory, $"{baseFileName}_mapped_{timestamp}.json");

                await File.WriteAllTextAsync(mappedFilePath, cleanedJson);

                return new ProcessingResult
                {
                    Success = true,
                    MappedFilePath = mappedFilePath,
                    InputTokens = inputTokens,
                    OutputTokens = outputTokens,
                    TotalCost = CalculateCost(inputTokens, outputTokens)
                };
            }
            catch (Exception ex)
            {
                return new ProcessingResult
                {
                    Success = false,
                    Error = $"Schema processing error: {ex.Message}"
                };
            }
        }

        private async Task<string> ValidateAndCleanJson(string jsonString)
        {
            try
            {
                // Parse the JSON string to a JsonNode for manipulation
                using var doc = JsonDocument.Parse(jsonString);
                var options = new JsonSerializerOptions
                {
                    WriteIndented = true,
                    PropertyNameCaseInsensitive = true,
                    PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                    DefaultIgnoreCondition = System.Text.Json.Serialization.JsonIgnoreCondition.WhenWritingNull
                };

                // Convert back to string with proper formatting
                var formattedJson = JsonSerializer.Serialize(doc.RootElement, options);

                // Validate against schema
                var schema = await File.ReadAllTextAsync(_schemaFilePath);
                var schemaDoc = JsonDocument.Parse(schema);
                var outputDoc = JsonDocument.Parse(formattedJson);

                // Basic structure validation
                if (!ValidateJsonStructure(outputDoc.RootElement, schemaDoc.RootElement))
                {
                    throw new JsonException("Generated JSON does not match the target schema structure");
                }

                return formattedJson;
            }
            catch (JsonException ex)
            {
                throw new JsonException($"Invalid JSON response: {ex.Message}", ex);
            }
        }

        private bool ValidateJsonStructure(JsonElement output, JsonElement schema)
        {
            try
            {
                if (schema.TryGetProperty("type", out var typeElement))
                {
                    var schemaType = typeElement.GetString();

                    if (schemaType == "object" && schema.TryGetProperty("properties", out var properties))
                    {
                        // For objects, check if required properties exist
                        if (schema.TryGetProperty("required", out var requiredProps))
                        {
                            foreach (var required in requiredProps.EnumerateArray())
                            {
                                var propName = required.GetString();
                                if (propName != null && !output.TryGetProperty(propName, out _))
                                {
                                    return false;
                                }
                            }
                        }
                    }
                    else if (schemaType == "array" && schema.TryGetProperty("items", out var items))
                    {
                        // For arrays, validate each item
                        if (!output.ValueKind.Equals(JsonValueKind.Array))
                        {
                            return false;
                        }
                    }
                }

                return true;
            }
            catch (Exception)
            {
                return false;
            }
        }

        private decimal CalculateCost(int inputTokens, int outputTokens)
        {
            const decimal INPUT_COST_PER_1K_TOKENS = 0.008m;
            const decimal OUTPUT_COST_PER_1K_TOKENS = 0.024m;

            var inputCost = (inputTokens / 1000m) * INPUT_COST_PER_1K_TOKENS;
            var outputCost = (outputTokens / 1000m) * OUTPUT_COST_PER_1K_TOKENS;

            return inputCost + outputCost;
        }
    }
}