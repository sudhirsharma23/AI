using Amazon.Lambda.Core;
using Amazon.S3;
using Amazon.Textract;
using Amazon.BedrockRuntime;
using Amazon.Textract.Model;
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Text.Json;
using System.Linq;
using System.IO;
using System.Text;
using Microsoft.Extensions.Caching.Memory;
using TextractProcessor.Services;
using TextractProcessor.Models;

[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace TextractProcessor
{
    public class Function
    {
        private const string LOG_GROUP = "/aws/lambda/textract-processor";
        private readonly string _functionName;

        private readonly IAmazonS3 _s3Client;
        private readonly IAmazonTextract _textractClient;
        private readonly SchemaMapperService _schemaMapper;
        private readonly IMemoryCache _cache;
        private readonly TextractCacheService _textractCache;

        private const string BucketName = "testbucket-sudhir-bsi1";
        private const string TextractRoleArn = "arn:aws:iam::912532823432:role/accesstextract-role";
        private const string SnsTopicArn = "arn:aws:sns:us-east-1:912532823432:sns-topic-textract.fifo";
        private static readonly string[] DocumentKeys = new[]
        {
      "uploads/2025000065659.tif",
    "uploads/2025000065659-1.tif"
        };
        private const int MaxRetries = 60;
        private const int RetryInterval = 5000;
        private const string OutputDirectory = "TextractResults";

        public Function()
        {
            _functionName = Environment.GetEnvironmentVariable("AWS_LAMBDA_FUNCTION_NAME") ?? "textract-processor";
            _s3Client = new AmazonS3Client();
            _textractClient = new AmazonTextractClient();
            _cache = new MemoryCache(new MemoryCacheOptions());
            _textractCache = new TextractCacheService(OutputDirectory);

            var bedrockClient = new AmazonBedrockRuntimeClient();
            var modelConfig = BedrockModelConfig.TitanTextExpress;
            var bedrockService = new BedrockService(bedrockClient, _cache, modelConfig);
            _schemaMapper = new SchemaMapperService(bedrockService, _cache, OutputDirectory);

            Directory.CreateDirectory(OutputDirectory);
        }

        private void LogMetric(ILambdaContext context, string metricName, double value, Dictionary<string, string> dimensions = null)
        {
            var logEntry = new
            {
                MetricName = metricName,
                Value = value,
                Unit = "Count",
                Dimensions = dimensions ?? new Dictionary<string, string>(),
                Timestamp = DateTime.UtcNow,
                RequestId = context?.AwsRequestId
            };

            context?.Logger.LogLine($"METRIC#{JsonSerializer.Serialize(logEntry)}");
        }

        private void LogEvent(ILambdaContext context, string message, string level = "INFO", Dictionary<string, object> additionalData = null)
        {
            var logEntry = new
            {
                Timestamp = DateTime.UtcNow,
                Level = level,
                RequestId = context?.AwsRequestId,
                FunctionName = _functionName,
                Message = message,
                AdditionalData = additionalData
            };

            context?.Logger.LogLine(JsonSerializer.Serialize(logEntry));
        }

        private float GetFloatValue(float? nullableValue)
        {
            return nullableValue ?? 0f;
        }

        public async Task<ProcessingResult> FunctionHandler(ILambdaContext context)
        {
            var startTime = DateTime.UtcNow;
            try
            {
                var textractResponses = new List<SimplifiedTextractResponse>();
                var allResponses = new List<TextractResponse>();

                // Process each document
                foreach (var documentKey in DocumentKeys)
                {
                    LogEvent(context, $"Starting document processing for {documentKey}", additionalData: new Dictionary<string, object>
  {
  { "DocumentKey", documentKey },
         { "Bucket", BucketName }
            });

   // Try to get cached Textract response
    var textractResponse = await _textractCache.GetCachedResponse(documentKey);

            if (textractResponse == null)
   {
   LogEvent(context, $"Cache miss - processing {documentKey} with Textract");
                textractResponse = await ProcessTextract(documentKey, context);

      if (textractResponse.JobStatus != "SUCCEEDED")
                {
      LogEvent(context, $"Textract processing failed for {documentKey}", "ERROR", new Dictionary<string, object>
      {
   { "Error", textractResponse.ErrorMessage }
      });
     return new ProcessingResult
  {
  Success = false,
            Error = $"Failed to process {documentKey}: {textractResponse.ErrorMessage}"
            };
    }

              LogMetric(context, "TextractProcessingTime", (DateTime.UtcNow - startTime).TotalMilliseconds);
           await _textractCache.CacheTextractResponse(documentKey, textractResponse);
     }
          else
       {
LogEvent(context, $"Using cached Textract response for {documentKey}");
    LogMetric(context, "CacheHit", 1);
  }

      allResponses.Add(textractResponse);

    // Create simplified response
            var simplifiedResponse = new SimplifiedTextractResponse
  {
       RawText = textractResponse.RawText,
                FormFields = textractResponse.FormData
               .SelectMany(dict => dict)
           .GroupBy(kvp => kvp.Key)
    .ToDictionary(
             g => g.Key,
             g => string.Join(" | ", g.Select(x => x.Value).Distinct())
              ),
        TableData = ExtractTableText(textractResponse.TableData)
          };

    textractResponses.Add(simplifiedResponse);
        }

 // Process merged responses with schema mapper
        LogEvent(context, "Processing merged documents with Bedrock", additionalData: new Dictionary<string, object>
        {
            { "DocumentCount", textractResponses.Count },
         { "TotalFormFields", textractResponses.Sum(r => r.FormFields.Count) },
       { "TotalTables", textractResponses.Sum(r => r.TableData.Count) }
     });

        var result = await _schemaMapper.ProcessAndMapSchema(
   textractResponses,
  string.Empty,
  "merged_documents"
  );

        var processingTime = (DateTime.UtcNow - startTime).TotalMilliseconds;
    LogMetric(context, "TotalProcessingTime", processingTime);
 LogMetric(context, "InputTokens", result.InputTokens);
        LogMetric(context, "OutputTokens", result.OutputTokens);

   LogEvent(context, "Processing completed", additionalData: new Dictionary<string, object>
      {
      { "ProcessingTimeMs", processingTime },
            { "InputTokens", result.InputTokens },
            { "OutputTokens", result.OutputTokens },
            { "Cost", result.TotalCost },
  { "OutputFile", result.MappedFilePath }
        });

        return result;
  }
    catch (Exception e)
    {
        LogEvent(context, "Processing failed", "ERROR", new Dictionary<string, object>
        {
     { "Error", e.Message },
   { "StackTrace", e.StackTrace }
   });

        return new ProcessingResult
        {
   Success = false,
   Error = e.Message
     };
    }
}